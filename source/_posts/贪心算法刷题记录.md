---
title: 贪心算法刷题记录
date: 2020-11-03 16:00:23
tags:
	-Leetcode
	-刷题
---

#### 贪心算法：总是做出在当前看来是最好的选择，也就是说，不从整体上考虑，得到局部最优解，局部最优即是全局最优。

贪心总是和排序纠缠不清，因此有必要弄清楚sort()函数的使用。

##### [力扣 455.分发饼干](https://leetcode-cn.com/problems/assign-cookies/)

这题的思路很简单，对两数组排序，从前匹配即可。

~~~c++
class Solution {
public:
    int findContentChildren(vector<int>& g, vector<int>& s) {
        sort(g.begin(),g.end());
        sort(s.begin(),s.end());
        int count = 0;
        int i = 0;
        int j = 0;
        while(i!=g.size()&&j!=s.size()){
        if(s[j]>=g[i]){
            count+=1;
            i++;
            j++;

        }else{
            j++;
        }
        }
        return count;
    }
};
~~~

##### [力扣 435.无重叠区间](https://leetcode-cn.com/problems/non-overlapping-intervals/)

先计算最多的不重叠区间个数，再用总个数减去不重叠的个数。

按区间结尾进行排序，每次选择结尾最小，并且和前一个区间不重叠的区间。

~~~c++
class Solution {
public:
    int eraseOverlapIntervals(vector<vector<int>>& intervals) {
        //对二维数组按照第一列排序，当第一列相同时按照第二列排序
        sort(intervals.begin(),intervals.end());
        int conut = 0;
        int n = intervals.size();
        //第一列的后位
        int left = intervals[0][1];
        for(int i = 1;i < n;i++){
            if(left>intervals[i][0]){
				count++;
                //已被删除的区间不再影响剩余的区间
                left = min(left,intervals[i][1]);
            }
            else{            
                left = intervals[i][1];
			 }
            
        }
        return count;
    }
};
~~~



#####  [力扣 452.最少的箭引爆气球](https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons/) 

魔改的不重叠区间。

~~~c++
class Solution {
  public:
  int findMinArrowShots(vector<vector<int>>& points) {
    if (points.size() == 0) return 0;
	sort(points.begin(),points.end());
    int n = points.size();
    left = points[0][1];
    int count = 0;
    for(int i=1;i<n;i++){
        if(left>=point[i][0]){
            count++;
       		left = min(left,points[i][1]);
            
        }
        left = points[i][1]; 
    }
   return n - count;
  }
};
~~~

[力扣 406.根据身高重建队列](https://leetcode-cn.com/problems/queue-reconstruction-by-height/)

此题思路清奇。

~~~c++

~~~

[力扣 121.买卖股票的最佳时机](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/)

思路：双指针错误

~~~c++
//解法错误。
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        if(prices.size()==0) return 0;
        int i = 0;
        int j = prices.size();
        int money = 0;
        while(i<=j){
            if(prices[i]>=prices[i+1]){
                i++;
            }
            if(prices[j]<prices[j-1]){
                j--;            
            }
            while(i<=j){
            money = prices[j]-prices[i];
            //这里会错过
            i++;
            j--;
            }
        }
        return money;
    }
};
~~~

单调找，动态规划

